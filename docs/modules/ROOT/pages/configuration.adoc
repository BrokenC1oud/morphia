== Configuration

Starting in Morphia 3.0, configuration will be driven via a configuration file rather than programmatic configuration.  This is being
done for a number of reasons:

1.  Better align with usage in frameworks such as Quarkus and Spring Boot
1.  Allow for deployment specific variations based on the deployment environment.

The configuration mechanism, build on https://microprofile.io/microprofile-config/[Microprofile Config], allows for a number of
variations which were awkward, at best, and usually downright impossible when using the traditional programmatic configuration.
Reference documentation for the configuration file can be found in the link:++javadoc/dev/morphia/config/MorphiaConfig.html++[javadoc] but
we'll go in depth on a few items here.  An example configuration file is included below.  All possible configuration elements are listed.
However, if the default values are acceptable that element can be safely omitted from your file.  The only element *required* to be
present is `morphia.database`.

=== Collection and property naming

Traditionally Morphia has used with the class's "simple name" for the collection name if you choose to not manually map the name of an entity's collection. Similarly, an entity's properties were named after the Java field name unless mapped otherwise with the `@Property` annotation. In 2.0, however, we define naming strategies. As of 2.0, the naming strategies supported out of the box are:

1. `identity` This is the legacy behavior Morphia has always used.
2. `lower` This is simply the lower case form of the `identity` strategy.
3. `snake` This transforms element names in to their https://en.wikipedia.org/wiki/Snake_case[snake case] versions.
For those coming from a Python background or who work with Python developers regularly, this should look familiar.
4. `camel` This transforms element names in to their https://en.wikipedia.org/wiki/Camel_case[camel case] versions.
This is the form most java developers will be familiar with.
5. `kebab` This transforms element names in to their https://en.wikipedia.org/wiki/Kebab_case[kebab case] versions.
This looks exactly like the `snake case` but with `-` instead of `_` so that it looks like it's on a kebab skewer.

These strategies can all be accessed via the link:++javadoc/dev/morphia/mapping/NamingStrategy.html++[NamingStrategy] class using their
named methods. If you need a custom naming strategy, perhaps some hashing function to obscure
element names, e.g., you can simply extend `NamingStrategy` yourself and implement whatever logic you might need.

=== Discriminator keys and values

Morphia has long hard coded the choice of how to encode an entity's type in to the resulting documents in the database using the
`className` key and the simple name of the class.
As of 2.0, you have a choice to change that if you'd like.
The new default is to use
`_t` as the discriminator property key.
This was chosen in part because of its use in other systems and also for its brevity.
By default, Morphia 2.0 stores the entity type unless you configure your types otherwise so saving space seemed prudent.

Similar to how collections and fields have a naming strategy, we can apply a global function to determine the discriminator values should we choose.
The choices here are simpler:

1. `className()`/`lowerClassName()`
2. `simpleName()`/`lowerSimpleName()`

 These call all be accessed via their named methods on `DiscriminatorFunction` and just like the `NamingStrategy` cases if the provided
  options are not sufficient, you can implement your own by subclassing `DiscriminatorFunction` and implementing your own function.

=== User-defined Codecs

Morphia makes heavy use of the driver's `Codec` infrastructure.
All of the persistence of your entities is handled by Morphia-defined and -configured codecs.
Morphia also makes use of driver-defined codecs with a select number of replacements more attuned to Morphia's needs.
This is typically sufficient for users' needs.
However, there are invariably times when more control is needed.

Starting with 2.3, you can provide your own `CodecProvider` to customize how Morphia handles the types you're interested.
It's not advised to write custom codecs for your entities (why mark them as entities at that point?) but if you're comfortable taking that on, then it is, of course, your prerogative.
You can register your custom `CodecProvider` implementation via the
link:++javadoc/dev/morphia/mapping/MapperOptions.Builder.html#codecProvider()++[MapperOptions.Builder#codecProvider(org.bson.codecs
.configuration.CodecProvider)]
method.
For details on how to write a `Codec` and a `CodecProvider`, please consult
https://www.mongodb.com/docs/drivers/java/sync/current/fundamentals/data-formats/codecs/[the driver's documentation].
Using your custom `CodecProvider`, you can supply as many `Codec` implementations as you need.

=== Old versus New

Morphia can be configured in one of two ways: the legacy mode and the modern mode.

==== Legacy

We'll cover the legacy mode first as it reflects how Morphia worked prior to 2.0.  `MapperOptions` drives the configuration and so this is where we'll start.
Prior to 2.0, you could simply create a `MapperOptions` instance directly.
Starting with 2.0, you will need to use one of the factory methods.
In this instance, you will want the `legacy()` method.
Among other things, this will configure Morphia to the legacy implementation of the `Query` class.
The `legacy()` builder currently configures the following settings:

1. `className` as the discriminator key
2. `className()` as the `DiscriminatorFunction`
3. `identity()` as both the class and field name strategies
4. Configures the legacy query implementation

==== Modern

One of the big goals for 2.0 was to modernize both the API and behavior of Morphia.
As such, the `builder()` method returns a
`Builder` that applies some updated defaults:

1. `_t` as the new discriminator key (replacing `className`)
2. `simpleName()` as the discriminator function used to determine these values
3. `camelCase()` is the default collection naming strategy
4. `identity()` remains the property naming strategy
5. A new `Query` implementation is configured enabling the new `Filters` based querying and disabling some older, deprecated methods.

=== Sample config file
```properties
# *optional*
morphia.codec-provider=
# default = camelCase
# possible values = camelCase, identity, kebabCase, lowerCase, snakeCase
morphia.collection-naming=camelCase
# *required*
morphia.database=dummy
# default = utc
# possible values = utc, system_default
morphia.date-storage=utc
# default = simpleName
# possible values = className, lowerClassName, lowerSimpleName, simpleName
morphia.discriminator=simpleName
# default = _t
morphia.discriminator-key=_t
# default = false
morphia.enable-polymorphic-queries=false
# default = false
morphia.ignore-finals=false
# default = false
morphia.map-subpackages=false
# default = fields
# possible values = fields, methods
morphia.property-discovery=fields
# default = identity
# possible values = camelCase, identity, kebabCase, lowerCase, snakeCase
morphia.property-naming=identity
# default = dev.morphia.query.DefaultQueryFactory
morphia.query-factory=dev.morphia.query.DefaultQueryFactory
# default = false
morphia.store-empties=false
# default = false
morphia.store-nulls=false
# default = standard
# possible values = unspecified, standard, c_sharp_legacy, java_legacy, python_legacy
morphia.uuid-representation=standard
```